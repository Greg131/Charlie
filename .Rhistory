jsonData
class(jsonData)
View(jsonData)
names(jsonData$owner)
View(jsonData)
View(jsonData)
View(jsonData)
View(my_matrix)
View(my_matrix2)
View(my_vector)
names(jsonData)
names(jsonData)
jsonData$owner$login
myjson <- toJSON(iris, pretty=TRUE)
class(myjson)
cat(myjson)
fileUrl <- "https://api.github.com/users/Greg131/repos"
jsonData <- fromJSON(fileUrl)
names(jsonData)
jsonData
class(jsonData)
names(jsonData$owner)
jsonData$owner$login
myjson <- toJSON(iris, pretty=TRUE)
class(myjson)
cat(myjson)
iris2 <- fromJSON(myjson)
head(iris2)
install.packages("data.table")
library(data.table)
DF = data.frame(x=rnorm(9), y=rep(c("a","b","c"), each=3), z=rnorm(9))
head(DFD,3)
head(DF,3)
DF
DT = data.table(x=rnorm(9), y=rep(c("a","b","c"), each=3), z=rnorm(9))
head(DT,3)
DT
class(DT)
tables()
DT[2,]
DT[DT$y="a",]
DT[DT$y=="a",]
DT[c(2,3)]  # un peu diff de DF... deux lignes (au lieu de col)
DF[c(2,3)]  #
DT[,c(2,3)]
{
x=1
y=2
}
k = {print(10); 5}
print(k)
DT[,list(mean(x),sum(z))]
DT[,table(y)]
setwd("~/Dropbox/Datascience/Datathon Simplon.co x SNCF/charlie")
getwd() # Get working directory
if (!file.exists("../data"))       {
dir.create("../data")
}
# Les fichiers de donn??es sont suppos??s ??tre dans ../data
? read.csv
# Lecture des fichiers
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv", fileEncoding = "UTF-16LE",sep = "\t")
setwd("~/Dropbox/Datascience/Datathon Simplon.co x SNCF/charlie")
getwd() # Get working directory
if (!file.exists("../data"))       {
dir.create("../data")
}
# Les fichiers de donn??es sont suppos??s ??tre dans ../data
? read.csv
# Lecture des fichiers
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv", fileEncoding = "UTF-16LE",sep = "\t")
View(Fonctions_AS_IdF)
Temperatures_PI <- read.csv("../data/Temperatures_PI.csv", sep = "\t",dec = ",")
REX_Incidents <- read.csv("../data/REX_Incidents.csv", sep = ";",check.names = FALSE)
REX_SIG <- read.csv("../data/REX SIG.csv", sep = ";",check.names = FALSE)
Referentiel_geomocalisation <- read.csv("../data/Referentiel geolocalisation.csv", sep = ";")
Liste_AVP <- read.csv("../data/Liste_AVP.csv",fileEncoding = "UTF-16LE",sep = "\t")
PI_TAG <- read.csv("../data/PI_TAG DCT.csv", sep = ";",check.names = FALSE)
PI_TAG <- read.csv("../data/PI_TAG DCT.csv", sep = ";",check.names = FALSE)
#PI_TAG2 <- read.csv("../data/PI_TAG DCT.csv", sep = ";",header = FALSE, skip = 1)
# pb dans les noms de variables ?? r??gler
Referentiel_geomocalisation <- read.csv("../data/Referentiel geolocalisation.csv", sep = ";")
REX_SIG <- read.csv("../data/REX SIG.csv", sep = ";",check.names = FALSE)
REX_Incidents <- read.csv("../data/REX_Incidents.csv", sep = ";",check.names = FALSE)
Temperatures_PI <- read.csv("../data/Temperatures_PI.csv", sep = "\t",dec = ",")
str(Temperatures_PI)
summary(Temperatures_PI)
Temperatures_PI
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv", fileEncoding = "UTF-16LE",sep = "\t")
str(Fonctions_AS_IdF)
Liste_AVP <- read.csv("../data/Liste_AVP.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_CTV <- read.csv("../data/Liste_CTV.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_EALE <- read.csv("../data/Liste_EALE.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_PN <- read.csv("../data/Liste_PN.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_Postes <- read.csv("../data/Liste_Postes.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_SAF_ADM <- read.csv("../data/Liste_SAF_ADM.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_Sous_Stations_SE <- read.csv("../data/Liste_Sous_Stations_SE.csv",fileEncoding = "UTF-16LE",sep = "\t")
Liste_Zones_Cdv <- read.csv("../data/Liste_Zones_Cdv.csv",fileEncoding = "UTF-16LE",sep = "\t")
PI_TAG <- read.csv("../data/PI_TAG DCT.csv", sep = ";",check.names = FALSE)
# ----------------------------------------------------------
# Datathon SNCF Simplon - Sujet 4 : "Où est Charlie?"
# ----------------------------------------------------------
setwd("~/Dropbox/Datascience/Datathon Simplon.co x SNCF/charlie")
getwd() # Get working directory
if (!file.exists("../data"))       {
dir.create("../data")
}
# Les fichiers de données sont supposés être dans ../data
? read.csv
# Lecture des fichiers
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv", fileEncoding = "UTF-16LE",sep = "\t")
add2 <- function(x,y) {
x+y
}
# pas de return.... return the last expression
add2(2,3)
x <- c(1,3,5,6)
y <- c(6,5,6,5)
add2(x,y)
above10 <- function(x) {
use <- x > 10
x[use]
}
above10(1:20)
x
above10(x)
above10(5*x)
above <- function(x,n) {
use <- x > n
x[use]
}
above(10,6)
above(1:20,4)
above(10)
# Valeur par d??faut des param??tres
above <- function(x,n = 10) {
use <- x > n
x[use]
}
above(11)
above(10)
above(9)
# Calcul de la moyenne de chaque colonne d'une matrice ou d'un data frame
columnmean <- function(x, removeNA = TRUE) {
nc <- ncol(x)
#  means = vector("numeric",nc)
means <- numeric(nc)
for (i in 1:nc) {
means[i] <- mean(x[,i], na.rm = removeNA)
}
means
}
x <- matrix (1:20, 4,5)
x
columnmean(x)
columnmean(2*x)
# ----------------------------------------------------------
# Week2 : Functions
# ----------------------------------------------------------
# funtion() directive... & stored as R Object
class(columnmean)
# "function"
# function can be passed as argument to other function, ...
# can be nested (define a function inside an other function )
# The return value is the last expression to be evaluated
# Named argument, wiich have potentially defaut values
# formal arguments...formal function return a list of all f arg ??
# Argument matching : position or names
help(rnorm)
mydata <- rnorm(100)
mydata <- rnorm(100, mean = 10, sd = 2)
class(mydata)
hist(mydata)
str(sd)
sd(mydata)
sd(x = mydata)
sd(x = mydata,F)
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata)
sd(na.rm = FALSE, mydata) # fonctionne egalement...pares enlev na.rm de la liste ordre, ...
# Position macching and name can be mix
args(lm)
str(lm)
names(alc4)
# 2 calls equivalents
lm(data=alc4, alc4$t ~ alc4$AGE, model = FALSE, 1:100)
lm(alc4$t ~ alc4$AGE, alc4,1:100, model = FALSE)
# Ex plotting function ... large arg list with default values...
# exact matc, partiel match, positional match
# ----------------------------------------------------------
# Week2 : Defining a Function
# ----------------------------------------------------------
f <- function(a,b=1,c=2,d=NULL){
}
# NULL there is nothing there
f
str(f)
args(f)
# Lazy Evaluation - arg evaluated only when needed
f <- function(a,b) {
print(a)
print(b)
}
f(45)
f(25,47)
f(25,"azer")
f(a=25)
f(b=2,a=5)
f <- function(a,b) {
print(a)
}
f(45)
f <- function(a,b = NULL) {
print(a)
print(b)
}
f(45)
f(25,47)
f(25,"azer")
f(a=25)
f(b=2,a=5)
# The "..." argument : variable number of arg
# 1) used when extending another function
myplot <- function(x,y,type = "1", ...) {
plot(x,y,type=type,...)
}
# 2) generic functions do nothing but dispach data, ...
# 3) when number of arg cannot be known in advanced...
args(paste)
args(cat)
# les arguments venant apres "..." doivent etre nomes explicitement et exactement
paste("a","b", sep =":")
paste("a","b", se =":") # attention pas de partial matching...
# ----------------------------------------------------------
# Week2 : Scoping Rules - Symbol Binding
# ----------------------------------------------------------
ls()
# 1) Global environement
# 2) search list of R package loaded currently into R
# ex lm <- function(){...}
search()
class(search())
search()[2]
library(Epi)
search()
search()[2]
# base package always at the end
# a chaque load le package vient en position 2 apres global evt
# noter qu'il y a des noms pour les functions et les autre obj
# donc une variable peut s'appeller lm sans conflit avec lm()...
sd <- 1
sd
sd(x = mydata)
# Scoping rule : how a value is associated with a free variable
# Dans ls fonctions, les arg et les autres
#...lexical scoping ou static scoping
# alternative a dynamic scoping
z <- 0
f <- function (x,y) {
x^2+y/z
}
# Lexical scoping in R means that
# Les valeur des variables libres sont cherchees dans l'environnement
# dans lequel la fonction a ete definie
# Un evironement est une collection de paires (symbol, value)
# Chaque environnement a un environnement pere,
# Il est possible d'avoir plusieurs environemenrts fils, ...
# Seul l'environnement vide n'a pas de pere
# Une fonction + environnement = "closure" ou "function closure"
# ex si fonction def dans glogbal evt... global puis parent search
# ex si def dans
f(2,3)
z
# top level evt usually global, ou package pour une f def dansun pack
# empty evt after the base package...
f <- function (x,y) {
z <-2
z
}
z <- 5
f(2,3)
z
f <- function (x,y) {
z
}
z <- 5
f(2,3) # dans ce cas trouve z dans le global evt ... 5
z
#----------------------
x
fx <- function(x){
x <-0
x
}
fx(x)
x
# ----------------------------------------------------------
# Week2 : R Scoping Rules
# ----------------------------------------------------------
# General - function definies sur global evt
# dans ce cas on peut avoir variables "Globales" des fonctions def dans evt glob
# function defined inside other function
# for ex a function can return a function
# ....environnement de def <> global
make.power <- function(n) {
pow <- function(x) {
x^n
}
pow
}
# fonction qui construit des fonctions
cube <- make.power(3)           # dans l'env de definition n vaut 3...
cube(8)
n <- 2
cube(8)
cube <- make.power(3)           # dans l'env de definition n vaut 3...
square <- make.power(2)
squareroot <- make.power(0.5)
class(cube)
cube(2)
squareroot(2)
n <- 1
make.power.glob <- function() {
pow.glob <- function(x) {
x^n
}
pow.glob
}
n <- 10
cube <- make.power.glob()           # dans l'env de definition n vaut 10...
cube(2)
n <- 1
cube(2)         # dans l'env de definition n vaut 1 maintenant...
# analyser l'environnement
ls(environment(cube))
get("n",environment(cube))
ls(environment(square))
get("n",environment(square))
# Lexical scoping vs Dynamic Scoping
y <- 10
f <- function(x){
y<-2
y^2+g(x) # g def dans le glob evt
}
g <- function(x){
x*y # y est def dans le global evt et vaut 10
}
f(3)
get("y",environment(f))
get("y",environment(g))
# dynamic scoping : se serait l'environnement appelant (parent frame) qui compte donc y =2
# NB si evt d'appel et de def estle meme
k <- 3
g <- function(x) {
a<-3
x+a+k
}
g(2)
k<-2
g(2)
# attention k est defini dans l'environnement de def qui est le meme que celui de l'appel
# Lexical scoping : Perl, Python, Common Lisp
# La consequence est que tous les objets doivent etre stockes en memoire.
# Chaque fonction doit maintenir unpointeur vers son environement de definition
# ----------------------------------------------------------
# Week2 : Scoping Rules - Optimization exemples
# ----------------------------------------------------------
# optim, nlm, optimize
# passer une fonction dont l'argument est un vecteur de parametres
# Par exemple les min ou max dependent non seulement des param
# mais aussi des data
# certains parametres sont fixes..
# Creer un constructeur de fonction qui construit la fonction objectif
# donc toutes les donnees dans le defining evt...
make.NegLogLik <- function(data, fixed=c(FALSE,FALSE)) {
params <- fixed
function(p) {
params[!fixed] <- p
mu <- params[1]
sigma <- params[2]
a <- -0.5*length(data)*log(2*pi*sigma^2)
b <- -0.5*sum((data-mu)^2) / (sigma^2)
-(a+b)
}
}
set.seed(1); normals <- rnorm(100,1,2)
hist(normals)
nLL <- make.NegLogLik(normals)
nLL
ls(environment(nLL))
help(optim)
optim(c(mu=0,sigma=1),nLL)$par
# Fixing sigma = 2
nLL <- make.NegLogLik(normals, c(FALSE,2))
optimize(nLL, c(-1,3))$minimum
setwd("~/Dropbox/Datascience/Universite_Johns-Hopkins/La_programmation_en_R/RBasics") # set working directory
getwd() # Get working directory
source("fichier_source.R")  # Analyse puis ??valuation s??quentielle...
?source
dir("~/Dropbox/Datascience") # donne les fichiers du "directory" / repertoire sp??cifie
length(dir("~/Dropbox/Datascience"))
dir() # ou du working directory par d??faut
class(dir())
# ls donne les objets R en m??moire
ls()  # retourne un vecteur avec le nom de objets
nb.objets <- length(ls())
nb.objets
myfunction()
second(4)
second(4:10)
# ----------------------------------------------------------
# R console Input and Evaluation
# ----------------------------------------------------------
# Expressions R, par exemple : "x <- 1"
x <- 1  # <- assignment operator
print(x)  # Functin print()
x # sans appeller la fonction print...nom de l'objet -> "auto printing"
# x is a R object "numeric" , c'est un vecteur "numeric" de "length" 1
class(x)
length(x)
msg <-  "hello" # Vecteur "character" premier elt "hello"
# les autre elements devront ??tre aussi des character
print(msg)
msg
class(msg)
length(msg)
# Explicit printing or auto printing
# Une expression est evaluee et le resultat de l'expression evaluee est retournee
# Creation de sequences
x <- 1:20
x
class(x)
length(x)
# x est un vecteur de "class" "integer" de "lenght" 20
# ----------------------------------------------------------
# Data types : Objects and attributs
# ----------------------------------------------------------
# 5 classes de base d'objet :
# "character",
# "numeric", reels double code sur 8 byte (8 octet de 8 bit), Inf et NaN
# "integer",
# "complex", nombres complexes
# "logical", TRUE ou FALSE (ou NA....)
?vector()
vector()
vector(mode = "logical", length = 2)
v <- vector(mode = "logical", length = 2)
v <- vector("logical", 2)
v
class(v)
v <- vector(mode = "complex", length = 2)
v
class(v)
v <- vector(mode = "numeric", length = 20)
v
# 1 traite par defaut en reel double...
# sauf si explicitement specifie par suffixe "L" : 1L
1
1L
1/0 # donne Inf
0/0 # donne NaN not a number...
class(1)
class(1L)
class(1/0)
class(0/0)
class(Inf)
class(NaN)
class(NA)       # "logical" bof... d??pend peut ??tre de n'importe quel type
# Attributs
# names, dimnames, dim, class, length...
?cbind
y <- cbind(a = 1:3, pi = pi) # combine les colonnes ... pour creer matrix with dimnames
y
z <- cbind(a = 1:3, b = 1, c= 2) # combine les colonnes ... pour creer matrix with dimnames
z
attributes(y)
class(y)
class(x)
length(x)
length(y) # donne le nombre total d'??l??ments
# ----------------------------------------------------------
# Vecteurs et listes
# ----------------------------------------------------------
# function c() autre fonction pour creer des vecteurs
# c comme concatenate
x <- c(0.5, 0.6)      ##  numeric vector
x
class(x)
x <- c(TRUE, FALSE)   ##  Logical vector
x
class(x)
x <- c(T,F)           ##  Logical vector
x
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv", fileEncoding = "UTF-16LE",sep = "\t")
setwd("~/Dropbox/Datascience/Datathon Simplon.co x SNCF/charlie")
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv", fileEncoding = "UTF-16LE",sep = "\t")
Fonctions_AS_IdF <- read.csv("../data/Fonctions_AS_Idf.csv",sep = "\t")
View(Fonctions_AS_IdF)
x <- data.frame(foo = 1:4, bar = c(T,F,T,F))
x
class(x)  # Class "data.frame"
attributes(x) # class, names, row.names
nrow(x)
ncol(x)
row.names(x)
names(x)
unclass(x) # est une liste a la base
y <- list(foo = 1:4,bar = c(T,F,T,F))
y
class(y)  # Class "data.frame"
attributes(y) # class, names, row.names
names(y)
